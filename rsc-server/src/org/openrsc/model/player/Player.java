package org.openrsc.model.player;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import org.jboss.netty.channel.Channel;
import org.openrsc.Config;
import org.openrsc.model.Constants;
import org.openrsc.model.GameMode;
import org.openrsc.model.Mob;
import org.openrsc.model.Npc;
import org.openrsc.model.NpcManager;
import org.openrsc.model.PlayerManager;
import org.openrsc.model.Privilege;
import org.openrsc.net.packet.Packet;
import org.openrsc.net.packet.PacketManager;
import org.openrsc.util.GameUtils;

public class Player extends Mob {

	// Packet Handling / Network
	private final Channel channel;
	private final BlockingQueue<Packet> packetQueue = new LinkedBlockingQueue<>();
	private final PacketDispatcher packetDispatcher;
	private long lastPacketReceived;

	/**
	 * The account id is an incremental value created by the database. It is
	 * permanent and will transfer between sessions.
	 */
	private int accountId;

	/**
	 * The session id is an incremental value generated by the server. It is a
	 * temporary value that regenerates upon login.
	 */
	private int sessionId;

	/**
	 * The account display name.
	 */
	private final String displayName;
	
	/**
	 * The account privilege.
	 */
	private Privilege privilege;
	
	/**
	 * The user's game mode.
	 */
	private GameMode gameMode;
	
	/**
	 * Premium membership status.
	 */
	private boolean isPremium = false;
	
	/**
	 */
	private boolean isMuted = false;

	/**
	 * A list of players that are within drawing distance.
	 * The client will only have information for these entities.
	 */
	private Set<Player> localPlayerList = null;

	/**
	 * A list of npcs that are within drawing distance.
	 * The client will only have information for these entities.
	 */
	private Set<Npc> localNpcList = null;

	private long lastYellTime = 0L;
	
	/**
	 * Npc pet slot.
	 */
	private Npc familiar;

	public Player(Channel channel, int accountId, int sessionId, String displayName) {
		super(sessionId, 3200, 3200);
		this.accountId = accountId;
		this.sessionId = sessionId;
		this.displayName = displayName;
		this.channel = channel;
		channel.setAttachment(this);
		this.packetDispatcher = new PacketDispatcher(this);
		this.lastPacketReceived = GameUtils.getCurrentTimeMillis();
	}

	@Override
	public void tick(long currentTime) {
		// Execute the queued packets.
		List<Packet> toProcess = new ArrayList<>();
		packetQueue.drainTo(toProcess);
		for (Packet packet : toProcess) {
			PacketManager.execute(this, packet);
			packetQueue.remove(packet);
		}
		
		// Idle logout timer.
		if (currentTime - lastPacketReceived > (60_000 * Config.IDLE_DISCONNECT)) {
			System.out.println("[" + displayName + "]Disconnected - Idle logout.");
			PlayerManager.getInstance().queueLogout(this);
			return;
		}

	}

	@Override
	public boolean isDead() {
		return false;
	}

	/**
	 */
	public void executeLogin() {
		this.privilege = Privilege.ROOT;
		this.isPremium = true;
		super.setLocation(Constants.DEFAULT_LOCATION);
		super.setTravelBack();

		packetDispatcher.sendMessage("Welcome to RuneScape.");
	}

	/**
	 */
	public void executeLogout() {
		packetQueue.clear();
		interrupt();
		if (familiar != null) {
			NpcManager.getInstance().unregister(familiar);
		}
		if (channel.isConnected()) {
			channel.disconnect();
		}
	}

	/**
	 */
	public void interrupt() {
		// Reset queued actions.
	}

	/**
	 * A cooldown check for the /yell command.
	 * 
	 * @return False if there is no cooldown.
	 */
	public boolean hasYellThrottle() {
		if (isDeveloper() || isModerator()) {
			return false;
		}
		long currentTimeMillis = GameUtils.getCurrentTimeMillis();
		if (currentTimeMillis - lastYellTime > (Constants.YELL_COMMAND_DELAY * 1000)) {
			lastYellTime = currentTimeMillis;
			return false;
		}
		return true;
	}

	/**
	 * The list of players which are visible client-side.
	 */
	public Set<Player> getLocalPlayerList() {
		return localPlayerList;
	}

	/**
	 * The list of npcs which are visible client-side.
	 */
	public Set<Npc> getLocalNpcList() {
		return localNpcList;
	}

	public Channel getChannel() {
		return channel;
	}

	public PacketDispatcher getPacketDispatcher() {
		return packetDispatcher;
	}

	public void updateLastPacketReceivedTime() {
		this.lastPacketReceived = GameUtils.getCurrentTimeMillis();
	}

	public int getAccountId() {
		return accountId;
	}

	public int getSessionId() {
		return sessionId;
	}

	public String getDisplayName() {
		return displayName;
	}

	public Privilege getPrivileges() {
		return privilege;
	}

	/**
	 * @return True, if the account has developer privileges.
	 */
	public boolean isDeveloper() {
		return privilege == Privilege.GITHUB_CONTRIBUTOR || privilege == Privilege.ADMINISTRATOR || privilege == Privilege.ROOT;
	}

	/**
	 * @return True, if the account has moderator privileges.
	 */
	public boolean isModerator() {
		return privilege != Privilege.REGULAR;
	}

	public GameMode getGameMode() {
		return gameMode;
	}

	/**
	 * @return True, if the account is a premium member.
	 */
	public boolean isPremium() {
		return isPremium;
	}

	/**
	 * @return True, if chatbox communication privileges are suspended.
	 */
	public boolean isMuted() {
		return isMuted;
	}

}