package org.openrsc.model.player;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import org.jboss.netty.channel.Channel;
import org.openrsc.Config;
import org.openrsc.model.Constants;
import org.openrsc.model.GameMode;
import org.openrsc.model.Mob;
import org.openrsc.model.Npc;
import org.openrsc.model.NpcManager;
import org.openrsc.model.PlayerManager;
import org.openrsc.model.Privilege;
import org.openrsc.net.packet.Packet;
import org.openrsc.net.packet.PacketManager;
import org.openrsc.util.GameUtils;

public class Player extends Mob {

    // Packet Handling / Network
    private final Channel channel;
    private final BlockingQueue<Packet> packetQueue = new LinkedBlockingQueue<>();
    private final PacketDispatcher packetDispatcher;
    private long lastPacketReceived;

    /**
     * The account id is an incremental value created by the database. It is
     * permanent and will transfer between sessions.
     */
    private int accountId;

    /**
     * The session id is an incremental value generated by the server. It is a
     * temporary value that regenerates upon login.
     */
    private int sessionId;

    /**
     * The account display name.
     */
    private final String displayName;

    /**
     * The account privilege.
     */
    private Privilege privilege;

    /**
     * The user's game mode.
     */
    private GameMode gameMode;

    /**
     */
    private boolean isMuted = false;

    /**
     * A list of nearby players. The client will only have information for these
     * entities.
     */
    private Set<Player> localPlayerList = null;

    /**
     * A list of nearby npcs. The client will only have information for these
     * entities.
     */
    private Set<Npc> localNpcList = null;

    private long lastYellTime = 0L;

    // TODO Appearance
    public int colourHairType;
    public int colourTopType;
    public int colourBottomType;
    public int colourSkinType;

    /**
     * Npc pet slot.
     */
    private Npc familiar;

    public Player(Channel channel, int accountId, int sessionId, String displayName) {
        super(sessionId, Constants.DEFAULT_LOCATION.getX(), Constants.DEFAULT_LOCATION.getZ());
        this.accountId = accountId;
        this.sessionId = sessionId;
        this.displayName = displayName;
        this.channel = channel;
        channel.setAttachment(this);
        this.packetDispatcher = new PacketDispatcher(this);
        this.lastPacketReceived = GameUtils.getCurrentTimeMillis();
    }

    @Override
    public void tick(long currentTime) {
        // Execute the queued packets.
        List<Packet> toProcess = new ArrayList<>();
        packetQueue.drainTo(toProcess);
        for (Packet packet : toProcess) {
            PacketManager.execute(this, packet);
            packetQueue.remove(packet);
        }

        // Idle logout timer.
        if (currentTime - lastPacketReceived > (60_000 * Config.IDLE_DISCONNECT)) {
            System.out.println("[" + displayName + "]Disconnected - Idle logout.");
            PlayerManager.getInstance().queueLogout(this);
            return;
        }

    }

    @Override
    public boolean isDead() {
        return false;
    }

    /**
     * Executed when the player gets registered.
     */
    public void executeLogin() {
        super.setLocation(Constants.DEFAULT_LOCATION);
        super.setTravelBack();
        packetDispatcher.sendMessage("Welcome to RuneScape.");
    }

    /**
     * Executed when the player gets unregistered.
     */
    public void executeLogout() {
        packetQueue.clear();
        interrupt();
        if (familiar != null) {
            NpcManager.getInstance().unregister(familiar);
        }
        if (channel.isConnected()) {
            channel.disconnect();
        }
    }

    /**
     * Queues an incoming packet to be executed in the next game tick.
     */
    public void addQueuedPacket(Packet packet) {
        this.packetQueue.add(packet);
    }

    /**
     */
    public void interrupt() {
        // Reset queued actions.
    }

    /**
     * A cooldown check for the /yell command.
     *
     * @return False if there is no cooldown.
     */
    public boolean hasYellThrottle() {
        if (isDeveloper() || isModerator()) {
            return false;
        }
        long currentTimeMillis = GameUtils.getCurrentTimeMillis();
        if (currentTimeMillis - lastYellTime > (Constants.YELL_COMMAND_DELAY * 1000)) {
            lastYellTime = currentTimeMillis;
            return false;
        }
        return true;
    }

    /**
     * The list of players which are visible client-side.
     */
    public Set<Player> getLocalPlayerList() {
        return localPlayerList;
    }

    /**
     * The list of npcs which are visible client-side.
     */
    public Set<Npc> getLocalNpcList() {
        return localNpcList;
    }

    public Channel getChannel() {
        return channel;
    }

    public PacketDispatcher getPacketDispatcher() {
        return packetDispatcher;
    }

    public void updateLastPacketReceivedTime() {
        this.lastPacketReceived = GameUtils.getCurrentTimeMillis();
    }

    public int getAccountId() {
        return accountId;
    }

    @Override
    public int getSessionId() {
        return sessionId;
    }

    public String getDisplayName() {
        return displayName;
    }

    public Privilege getPrivileges() {
        return privilege;
    }

    public void setPrivileges(Privilege privilege) {
        this.privilege = privilege;
    }

    /**
     * @return True, if the account has developer privileges.
     */
    public boolean isDeveloper() {
        return privilege == Privilege.GITHUB_CONTRIBUTOR || privilege == Privilege.ADMINISTRATOR
                || privilege == Privilege.ROOT;
    }

    /**
     * @return True, if the account has moderator privileges.
     */
    public boolean isModerator() {
        return privilege != Privilege.REGULAR;
    }

    public GameMode getGameMode() {
        return gameMode;
    }

    /**
     * @return True, if chatbox communication privileges are suspended.
     */
    public boolean isMuted() {
        return isMuted;
    }

}